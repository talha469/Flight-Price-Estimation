# -*- coding: utf-8 -*-

#Changes for Github

"""Flight_Price_Estimator

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xztWHbCk4bBO-Kq6eY0BKmYU-iZSRbmr
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

pd.set_option('display.max_columns',35)
data = pd.read_excel("/content/Flight_estimator.xlsx")
print(data.head())

#Dealing with missing values
#print(data.shape)
#print(data.isna().sum())
data = data.dropna()
#print(data.isna().sum())
#print(data.shape)
#print(data.dtypes)

#Convert data types as desired
def Change_datetime(col):
    data[col] = pd.to_datetime(data[col])

for i in ['Date_of_Journey','Dep_Time','Arrival_Time']:
    Change_datetime(i)

#print(data.dtypes)

#Seperating date and month
data['Journey_Month'] = data['Date_of_Journey'].dt.month
data['Journey_Date'] = data['Date_of_Journey'].dt.date

#print(data.head)

#Droping Date_of_journey coloumn
data.drop('Date_of_Journey',axis = 1,inplace = True)
#print(data.head())

#Seprating Hour and minute from Departure time
def extractDepTime(col):
    data[col+'_hour'] = data[col].dt.hour
    data[col+'_Minute'] = data[col].dt.minute
extractDepTime('Dep_Time')
data.drop('Dep_Time',axis=1,inplace=True)
#print(data.head())
#Separating Hour and minute from Arrival Time
extractDepTime('Arrival_Time')
data.drop('Arrival_Time',axis =1,inplace=True)
#print(data.head())

#Appending hour and minutes in Duration coloumn
duration = list(data['Duration'])
for i in range(len(duration)):
    if len(duration[i].split(" ")) == 2:
        pass
    else:
        if 'h' in duration[i]:
            duration[i] = duration[i] + ' 0m'
        else:
            duration[i] = '0h '+duration[i]
data['Duration'] = duration

#Separating Hour and minutes from Duration Coloumn
def hour(col):
    return col.split(" ")[0][0:-1]
def minute(col):
    return col.split(" ")[1][0:-1]
data['Duration_Hour'] = data['Duration'].apply(hour)
data['Duration_Minute'] = data['Duration'].apply(minute)
data.drop('Duration',axis=1,inplace=True)
#print(data.head())
#print(data.dtypes)
data['Duration_Hour'] = data['Duration_Hour'].astype(int)
data['Duration_Minute'] = data['Duration_Minute'].astype(int)
#print(data.dtypes)

###Separating Categorical and continuous data
categorical = [col for col in data.columns if data[col].dtype == 'O']
#print(categorical)
continuous = [col for col in data.columns if data[col].dtype != 'O']
#print(continuous)

#Categorical data are of two types
#1_Nominal Data  data that is not in any order e.g name of country
#perform one-hot encoding

#2_Ordinal data data have some hirerachy
#label encoding

#Handling Airline data
categorical_data = data[categorical]
#print(categorical_data['Airline'].value_counts())
plt.figure(figsize=(20,5))
sns.boxplot(x = 'Total_Stops', y='Price',data = data.sort_values('Total_Stops',ascending=False))
#plt.show()

##Performing one-hot encoding
Airline = pd.get_dummies(categorical_data['Airline'],drop_first=True)
Source = pd.get_dummies(categorical_data['Source'],drop_first=True)
Destination = pd.get_dummies(categorical_data['Destination'],drop_first=True)

#Handling Route
categorical_data['Route_1'] = categorical_data['Route'].str.split('→').str[0]
categorical_data['Route_2'] = categorical_data['Route'].str.split('→').str[1]
categorical_data['Route_3'] = categorical_data['Route'].str.split('→').str[2]
categorical_data['Route_4'] = categorical_data['Route'].str.split('→').str[3]
categorical_data['Route_5'] = categorical_data['Route'].str.split('→').str[4]

#print(categorical_data['Route_1'])

categorical_data.drop('Route',axis=1,inplace=True)
#print(categorical_data.isnull().sum())

for i in ['Route_3','Route_4','Route_5']:
    categorical_data[i].fillna('None',inplace = True)
#print(categorical_data.isnull().sum())
##Checking number of categories in the data
for i in categorical_data.columns:
    print('{} has total {} categories'.format(i,len(categorical_data[i].value_counts())))
##Route3 and Route4 have much categories so ont-hot encoding doesn't suits here
##Using lable encoding
from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
for i in ['Route_1','Route_2','Route_3','Route_4','Route_5']:
    categorical_data[i] = encoder.fit_transform(categorical_data[i])

categorical_data.drop('Additional_Info',axis = 1)

#Replacing Total stops with numerical data
dictionary = {'non-stop':0, '1 stop':1, '2 stop':2, '3 stop':3, '4 stop':4}
categorical_data['Total_Stops'] = categorical_data['Total_Stops'].map(dictionary)
#print(categorical_data.head())

#Concatinating the data
training_data = pd.concat([categorical_data.Airline,Source,Destination,data[continuous]],axis=1)
#print(training_data.head(),'/n')

training_data.drop('Airline',axis =1,inplace=True)

training_data.head()

def plot(col):
  fig,(axis1, axis2) = plt.subplots(2,1)
  sns.displot(training_data[col],ax =axis1)
  sns.boxplot(training_data[col], ax = axis2)

plot('Price')

"""From the graph it is clear that it is positive skewed"""

training_data['Price'] = np.where(training_data['Price']>=35000,training_data['Price'].median(),training_data['Price'])
plot('Price')

#Seperating dependent and independent features
X = training_data.drop('Price',axis=1)
y = training_data['Price']
X.head()

#Selecting Best features
import sklearn
from sklearn.feature_selection import mutual_info_classif
mutual = mutual_info_classif(X,y)

feteched_data = pd.DataFrame(mutual, index=X.columns)
feteched_data.columns = ['Importance']
feteched_data.sort_values(by = 'Importance',ascending=False )

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,y,test_size = 0.2)

from sklearn import metrics
import pickle
def prediction(ml_model,number):
  model = ml_model.fit(x_train,y_train)
  print('Training score: {}'.format(model.score(x_train,y_train)))
  predictions = model.predict(x_test)
  print('Predictions are {}'.format(predictions))
  print('\n')
  r2_score = metrics.r2_score(y_test,predictions)
  print('r2 score is {}'.format(r2_score))
  print('MAE:',metrics.mean_absolute_error(y_test,predictions))
  print('MSE:',metrics.mean_squared_error(y_test,predictions))
  print('RMSE:',np.sqrt(metrics.mean_absolute_error(y_test,predictions)))
  sns.displot(predictions) 

  if number == 1:
    file = '/content/RandomForestRegression.pkl'
    with open(file, "wb") as File:
      pickle.dump(model, File)

from sklearn.ensemble import RandomForestRegressor
prediction(RandomForestRegressor(),1)

#trying algorithms
from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeClassifier
prediction(LinearRegression(),0)
prediction(KNeighborsRegressor(),0)
prediction(DecisionTreeClassifier(),0)